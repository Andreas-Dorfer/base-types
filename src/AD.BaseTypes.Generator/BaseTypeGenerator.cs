using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

namespace AD.BaseTypes.Generator
{
    [Generator]
    public class BaseTypeGenerator : ISourceGenerator
    {
        static readonly Regex
            BaseTypeDefinitionRegex = new Regex("^AD.BaseTypes.IBaseTypeDefinition<(?<type>.+)>$"),
            BaseTypeValidatedRegex = new Regex("^AD.BaseTypes.IBaseTypeValidation<(?<type>.+)>$");
        const string
            BaseTypeAttributeName = "AD.BaseTypes.BaseTypeAttribute",
            Cast_Explicit = "Explicit",
            Cast_Implicit = "Implicit",
            Cast_None = "None";

        public void Initialize(GeneratorInitializationContext context)
        {
            //AttachDebugger();
            context.RegisterForSyntaxNotifications(() => new PartialRecordsWithAttributesReceiver());
        }

        class PartialRecordsWithAttributesReceiver : ISyntaxReceiver
        {
            public List<RecordDeclarationSyntax> Records { get; } = new List<RecordDeclarationSyntax>();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is RecordDeclarationSyntax record &&
                    record.Modifiers.Any(SyntaxKind.PartialKeyword) &&
                    GetAllAttributes(record).Any())
                {
                    Records.Add(record);
                }
            }
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var config = ReadConfig(context);

            foreach (var record in ((PartialRecordsWithAttributesReceiver)context.SyntaxReceiver).Records)
            {
                var semantics = context.Compilation.GetSemanticModel(record.SyntaxTree);

                var attributes = GetAllAttributes(record);
                if (!TryGetBaseType(semantics, attributes, out var baseType)) continue;

                var sourceBuilder = new IndentedStringBuilder();

                sourceBuilder.AppendLine("// <auto-generated> This file was generated by AD.BaseTypes. </auto-generated>");
                sourceBuilder.AppendLine("#nullable enable");

                var @namespace = GetNamespace(record);
                var hasNamespace = !string.IsNullOrEmpty(@namespace);
                if (hasNamespace)
                {
                    //namespace start
                    sourceBuilder.AppendLine($"namespace {@namespace}");
                    sourceBuilder.AppendLine("{");
                    sourceBuilder.IncreaseIndent();
                    //*****
                }

                //record start
                var recordName = record.Identifier.Text;
                if (config?.AllowNullLiteral == false)
                {
                    sourceBuilder.AppendLine("[Microsoft.FSharp.Core.AllowNullLiteral(false)]");
                }
                sourceBuilder.AppendLine($"[System.ComponentModel.TypeConverter(typeof(AD.BaseTypes.Converters.BaseTypeTypeConverter<{recordName}, {baseType}>))]");
                sourceBuilder.AppendLine($"[System.Text.Json.Serialization.JsonConverter(typeof(AD.BaseTypes.Json.BaseTypeJsonConverter<{recordName}, {baseType}>))]");
                sourceBuilder.AppendLine($"sealed partial record {recordName} : System.IComparable<{recordName}>, System.IComparable, AD.BaseTypes.IBaseType<{baseType}>");
                sourceBuilder.AppendLine("{");
                sourceBuilder.IncreaseIndent();
                //*****

                //constructor start
                sourceBuilder.AppendLine($"public {recordName}({baseType} value)");
                sourceBuilder.AppendLine("{");
                sourceBuilder.IncreaseIndent();
                //*****

                AppendValidations(sourceBuilder, semantics, attributes, baseType);
                sourceBuilder.AppendLine("this.Value = value;");

                //constructor end
                sourceBuilder.DecreaseIndent();
                sourceBuilder.AppendLine("}");
                //*****

                sourceBuilder.AppendLine($"public {baseType} Value {{ get; }}");
                sourceBuilder.AppendLine("public override string ToString() => Value.ToString();");
                sourceBuilder.AppendLine($"public int CompareTo(object? obj) => CompareTo(obj as {recordName});");
                sourceBuilder.AppendLine($"public int CompareTo({recordName}? other) => other is null ? 1 : System.Collections.Generic.Comparer<{baseType}>.Default.Compare(Value, other.Value);");
                AppendCast(sourceBuilder, semantics, attributes, baseType, recordName);
                sourceBuilder.AppendLine($"public static {recordName} Create({baseType} value) => new(value);");

                //record end
                sourceBuilder.DecreaseIndent();
                sourceBuilder.AppendLine("}");
                //*****

                if (hasNamespace)
                {
                    //namespace end
                    sourceBuilder.DecreaseIndent();
                    sourceBuilder.AppendLine("}");
                    //*****
                }

                var fileHint = hasNamespace ? $"{@namespace}.{recordName}" : recordName;
                context.AddSource($"{fileHint}.g", sourceBuilder.ToString());
            }
        }

        static readonly Regex ConfigKeyValueRegex = new Regex(@"""(?<key>.+)""\s*:\s*(?<value>.+);?");

        static Config ReadConfig(GeneratorExecutionContext context)
        {
            var configFile = context.AdditionalFiles.FirstOrDefault(_ => _.Path.EndsWith("AD.BaseTypes.Generator.json"));
            if (configFile == null) return default;
            var text = File.ReadAllText(configFile.Path);

            var config = new Config();
            foreach (Match match in ConfigKeyValueRegex.Matches(text))
            {
                switch (match.Groups["key"].Value)
                {
                    case nameof(config.AllowNullLiteral):
                        if (bool.TryParse(match.Groups["value"].Value, out var allowNullLiteral))
                        {
                            config.AllowNullLiteral = allowNullLiteral;
                        }
                        break;
                }
            }
            return config;
        }

        static IEnumerable<AttributeSyntax> GetAllAttributes(RecordDeclarationSyntax record) =>
            record.AttributeLists.SelectMany(_ => _.Attributes);

        static bool TryGetBaseType(SemanticModel semantics, IEnumerable<AttributeSyntax> attributes, out string baseType)
        {
            var baseTypes = GetBaseTypes(semantics, attributes);
            if (baseTypes.Length != 1)
            {
                baseType = default;
                return false;
            }
            baseType = baseTypes[0];
            return true;
        }

        static string[] GetBaseTypes(SemanticModel semantics, IEnumerable<AttributeSyntax> attributes) =>
            attributes.SelectMany(attribute =>
                semantics.GetSymbolInfo(attribute).Symbol?.ContainingType.AllInterfaces.Select(@interface =>
                {
                    var match = BaseTypeDefinitionRegex.Match(@interface.ToDisplayString());
                    return match.Success ? match.Groups["type"].Value : null;
                }) ?? Enumerable.Empty<string>())
            .Where(_ => _ != null).Distinct().ToArray();

        static string GetNamespace(RecordDeclarationSyntax record)
        {
            var namespaces = FindParentNamespaces(record).Select(_ => _.Name).Reverse();
            return string.Join(".", namespaces);
        }

        static IEnumerable<NamespaceDeclarationSyntax> FindParentNamespaces(SyntaxNode node)
        {
            for (; node != null; node = node.Parent)
            {
                if (node is NamespaceDeclarationSyntax @namespace) yield return @namespace;
            }
        }

        static void AppendValidations(IndentedStringBuilder sourceBuilder, SemanticModel semantics, IEnumerable<AttributeSyntax> attributes, string baseType)
        {
            foreach (var validation in GetAllValidations(semantics, attributes, baseType))
            {
                var validationType = semantics.GetSymbolInfo(validation).Symbol.ContainingType;
                var args = validation?.ArgumentList?.Arguments.ToString() ?? "";
                sourceBuilder.AppendLine($"new {validationType.ToDisplayString()}({args}).Validate(value);");
            }
        }

        static void AppendCast(IndentedStringBuilder sourceBuilder, SemanticModel semantics, IEnumerable<AttributeSyntax> attributes, string baseType, string recordName)
        {
            switch (GetCast(semantics, attributes))
            {
                default:
                case Cast_Explicit:
                    sourceBuilder.AppendLine($"public static explicit operator {baseType}({recordName} item) => item.Value;");
                    break;
                case Cast_Implicit:
                    sourceBuilder.AppendLine($"public static implicit operator {baseType}({recordName} item) => item.Value;");
                    break;
                case Cast_None:
                    break;
            }
        }

        static string GetCast(SemanticModel semantics, IEnumerable<AttributeSyntax> attributes)
        {
            var configs = attributes.Where(attribute => semantics.GetSymbolInfo(attribute).Symbol?.ContainingType.ToDisplayString() == BaseTypeAttributeName).ToArray();
            if (configs.Length != 1) return null;
            var args = configs[0].ArgumentList.Arguments;
            if (args.Count != 1) return null;

            var expression = args[0].Expression as MemberAccessExpressionSyntax;
            if (expression is null) return null;

            return expression.Name.Identifier.Text;
        }

        static IEnumerable<AttributeSyntax> GetAllValidations(SemanticModel semantics, IEnumerable<AttributeSyntax> attributes, string baseType) =>
            attributes.Where(a =>
                semantics.GetSymbolInfo(a).Symbol?.ContainingType.AllInterfaces.Any(i =>
                {
                    var match = BaseTypeValidatedRegex.Match(i.ToDisplayString());
                    return match.Success && match.Groups["type"].Value == baseType;
                }) ?? false);

#pragma warning disable IDE0051 // Remove unused private members
        [Conditional("DEBUG")]
        static void AttachDebugger()
        {
            if (!Debugger.IsAttached)
            {
                Debugger.Launch();
            }
        }
#pragma warning restore IDE0051 // Remove unused private members
    }
}
