using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using System.Text.RegularExpressions;
using static AD.BaseTypes.Generator.Utils;
using System.Text;

namespace AD.BaseTypes.Generator;

[Generator]
public class StaticBaseTypeValidationGenerator : ISourceGenerator
{
    static readonly Regex
        StaticBaseTypeValidationAttributeRegex = new("^AD\\.BaseTypes\\.StaticBaseTypeValidationAttribute<(?<type>.+)>\\.StaticBaseTypeValidationAttribute\\(\\)$", RegexOptions.Compiled),
        ParamRegex = new("<param name=\"(?<name>.+?)\">.+?</param>", RegexOptions.Compiled);

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new StaticBaseTypeValidationsReceiver());
    }

    class StaticBaseTypeValidationsReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> Classes { get; } = new List<ClassDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is ClassDeclarationSyntax @class &&
                @class.Modifiers.Any(SyntaxKind.PartialKeyword) &&
                @class.AttributeLists.SelectMany(_ => _.Attributes).Any())
            {
                Classes.Add(@class);
            }
        }
    }

    public void Execute(GeneratorExecutionContext context)
    {
        foreach (var @class in (context.SyntaxReceiver as StaticBaseTypeValidationsReceiver)?.Classes ?? Enumerable.Empty<ClassDeclarationSyntax>())
        {
            var semantics = context.Compilation.GetSemanticModel(@class.SyntaxTree);
            var attributes = GetAllStaticBaseTypeValidationAttributes(semantics, @class).ToArray();
            if (attributes.Length != 1) continue;

            var validate = @class.Members.OfType<MethodDeclarationSyntax>().Where(_ =>
                _.Modifiers.Any(SyntaxKind.PublicKeyword) &&
                _.Modifiers.Any(SyntaxKind.StaticKeyword) &&
                _.ReturnType.ToString() == "void" &&
                _.Identifier.ValueText == "Validate" &&
                _.ParameterList.Parameters.Count > 0 &&
                _.ParameterList.Parameters[0].Type is not null &&
                semantics.GetTypeInfo(_.ParameterList.Parameters[0].Type!).Equals(semantics.GetTypeInfo(attributes[0].Item2))).FirstOrDefault();
            if (validate is null) continue;

            var typeName = attributes[0].Item1;

            IndentedStringBuilder sourceBuilder = new();

            sourceBuilder.AppendLine("// <auto-generated> This file was generated by AD.BaseTypes. </auto-generated>");
            sourceBuilder.AppendLine("#nullable enable");

            var @namespace = GetNamespace(@class, semantics);
            if (!string.IsNullOrEmpty(@namespace))
            {
                //namespace
                sourceBuilder.AppendLine($"namespace {@namespace};");
                sourceBuilder.AppendLine("");
            }

            //class start
            var className = @class.Identifier.Text;
            sourceBuilder.AppendLine("[System.AttributeUsage(System.AttributeTargets.Class)]");
            sourceBuilder.AppendLine($"sealed partial class {className} : System.Attribute, AD.BaseTypes.IStaticBaseTypeValidation<{typeName}>");
            sourceBuilder.AppendLine("{");

            if (validate.ParameterList.Parameters.Count > 1)
            {
                sourceBuilder.IncreaseIndent();

                StringBuilder comment = new();
                foreach (var line in validate.GetLeadingTrivia().Where(_ => _.IsKind(SyntaxKind.SingleLineDocumentationCommentTrivia) || _.IsKind(SyntaxKind.SingleLineCommentTrivia)))
                {
                    comment.Append(line.ToFullString());
                }
                Dictionary<string, string> paramComments = new();
                foreach (Match match in ParamRegex.Matches(comment.ToString()))
                {
                    paramComments[match.Groups["name"].Value] = match.Value;
                }
                for (int i = 1; i < validate.ParameterList.Parameters.Count; i++)
                {
                    var paramName = validate.ParameterList.Parameters[i].Identifier.Text;
                    if (paramComments.TryGetValue(paramName, out var c))
                    {
                        sourceBuilder.AppendLine($"/// {c}");
                    }
                }

                sourceBuilder.Append("#pragma warning disable IDE0060 // Remove unused parameter");
                sourceBuilder.EndLine();

                //ctor start
                sourceBuilder.Indent();
                sourceBuilder.Append($"public {className}(");
                for (int i = 1; i < validate.ParameterList.Parameters.Count; i++)
                {
                    var param = validate.ParameterList.Parameters[i];
                    if (i > 1)
                    {
                        sourceBuilder.Append(", ");
                    }
                    sourceBuilder.Append(param.GetText().ToString());
                }
                sourceBuilder.Append(")");
                sourceBuilder.EndLine();
                sourceBuilder.AppendLine("{ }");
                sourceBuilder.DecreaseIndent();
                //ctor end

                sourceBuilder.Append("#pragma warning restore IDE0060 // Remove unused parameter");
                sourceBuilder.EndLine();
            }

            //class end
            sourceBuilder.AppendLine("}");

            var fileHint = !string.IsNullOrEmpty(@namespace) ? $"{@namespace}.{className}" : className;
            context.AddSource($"{fileHint}.g", sourceBuilder.ToString());
        }
    }

    static IEnumerable<(string, TypeSyntax)> GetAllStaticBaseTypeValidationAttributes(SemanticModel semantics, ClassDeclarationSyntax @class) =>
        @class.AttributeLists.SelectMany(_ => _.Attributes).Select(a =>
        {
            var match = StaticBaseTypeValidationAttributeRegex.Match(semantics.GetSymbolInfo(a).Symbol?.ToDisplayString() ?? "");
            if (!match.Success) return default;
            var type = a.DescendantNodes(_ => true).OfType<TypeArgumentListSyntax>().SelectMany(_ => _.Arguments).FirstOrDefault();
            return (match.Groups["type"].Value, type);
        }).Where(_ => _ != default).GroupBy(_ => _.Value).Select(_ => (_.Key, _.First().type));

}
